[{"title":"熵增","url":"/2024/12/30/2024-12-30/","content":"\n> 热力学第二定律指出，在一个封闭系统中，熵总是趋于增加\n\n熵总是增加的，混乱度总是增加的，只有熵减才能对抗熵增。减熵的本质是对抗无序和混乱，维持或创造有序和高效的状态。\n\n大脑思维的熵增（胡思乱想）可以通过学习、阅读、知识整理来对抗。\n\n学会控制情绪这也是熵减\n"},{"title":"You don't know JS","url":"/2024/12/01/2024-12-01/","content":"\nLHS与RHS\n\n作用域分为:\n1. 词法作用域\n> 关注函数在何处声明\n2. 动态作用域\n> 关注函数在何处调用\n\n某种意义上来说，this和动态作用域有相似之处。this的绑定和函数声明的位置没有关系，只取决于函数的调用方式\n\n当函数可以记住并访问所在的词法作用域时，就产生了闭包。函数在定义时的词法作用域以外的地方\n被调用，闭包使得函数可以继续访问定义时的词法作用域\n\n变量没有类型，只有值才有类型\n","tags":["JavaScript"]},{"title":"面试反问问题记录","url":"/2024/10/21/2024-10-21/","content":"\n### 关于岗位\n1. 同一个项目最多几人协作\n2. 最近一次大规模的重构是什么时候\n3. 有没有code review\n4. 最长连续加班多少天\n5. 休息日需不需要跟踪bug\n6. 版本管理工具用的git还是svn\n7. 如果是git的话合并代码用merge还是rebase\n8. 目前在维护项目的项目规模，代码量有多少\n9. 针对大型项目开发有没有比较好的项目管理上的经验\n10. 开会的频率 周会 晨会\n11. 是否有需求文档、技术文档\n12. 开发流程是怎样的\n\n### 关于公司\n1. 试用期工资\n2. 试用期几个月\n3. 劳动合同签几年\n4. 年终奖几个月\n5. 年终奖什么时候发\n6. 合同上的工资构成\n7. 合同上会写年终奖吗\n8. 年终奖怎样计算（当年工作月份/12）试用期是否算在内\n9. 考勤 上下班时间 午休时间\n10. 加班有没有加班费\n11. 其他的福利没/餐补\n12. 为什么现在招人\n\n### 公司商业\n1. 盈利了没\n2. 怎样赚到钱\n\n### 环境考查（上班时间面试10点-11点 14:30 17:30） \n1. 工位\n2. 工作氛围\n","tags":["面试"]},{"title":"逆向学习（二）","url":"/2024/08/18/2024-08-18/","content":"\n在学习过程中，又了解到了几种针对爬虫的限制机制。\n\n### 页面加载设置cookie\n字符串拼接cookie有后端生成动态脚本，查找cookie字段名字找不到，但是可以找document.cookie呀\n\n### 参数base64\nbase64是一种很有特征的编码，就算看不出，常用的编码那几种挨个试一下，哪个返回正确就是哪个\n\n### http2\nrequests不支持http2，建议使用httpx\n\n```python\nwith httpx.Client(http2=True) as client:\n    pass\n```\n\n### tls指纹特征\n服务器使用tls的cipher suits等字段生成独特的客户端ID。\n使用Wireshark等抓包工具查找TLS layer中ServerHello消息，`ssl.handshake.type == 2`。\n如果你使用httpx，可以使用如下方式设置httpx的ssl_context\n\n```python\nimport httpx\nssl_context = httpx.create_ssl_context()\nssl_context.set_ciphers('ECDHE-RSA-AES128-GCM-SHA256')\n\nwith httpx.Client(http2=True, verify=ssl_context) as client:\n    pass\n```\n","tags":["web逆向"]},{"title":"Arch Linux安装","url":"/2024/07/24/2024-07-24/","content":"\n安装了sway、alacritty、sddm，没有配置sway，导致登录后alacritty不能被打开，没有任何方法进\n终端，只能重新安装\n\ngtk2 gtkmm gtkmm3 xf86-video-vmware 剪贴板 vmware中屏幕比例调账\n\n### Arch Linux配置i3wm\n1. 安装xorg\n```sh\npacman -S xorg xorg-server xorg-xinit\n```\n2. 安装i3\n3. 拷贝xorg默认配置```cp /etc/X11/xinit/xinitrc ~/.xinitrc```\n4. 在xorg配置中添加i3启动项```exec i3```\n5. 安装桌面管理sddm，默认启动```systemctl enable sddm```\n","tags":["Linux"]},{"title":"TODO","url":"/2024/07/12/2024-07-12/","content":"\n<div style=\"display: inline-flex; width: 600px\">\n\t<span>进度：</span>\n\t<div style=\"width: 100%; background-color: #e0e0e0; border-radius: 5px;flex: 1;\">\n\t\t<div style=\"width: 36%; background-color: #76c7c0; height: 20px; border-radius: 5px;\"></div>\n\t</div>\n\t<span>40%</span>\n</div>\n\n### 和时间做朋友\n复利\n\n积少成多 知足常乐\n\n### TODO\n\n[ ] 扩大上下文窗口 增加知识储备（可以将更多事情关联在一起，能从更多的角度来看待问题）\n\n[ ] Python文档\n\n[ ] 逆向学习（思路）\n\n[ ] 财务\n"},{"title":"在zsh更改快捷键","url":"/2024/04/01/2024-04-01/","content":"\nZsh 是一种功能强大的 shell，提供了许多功能和定制选项，其中包括更改快捷键。快捷键可以让用户更高效地操作命令行界面，并根据个人偏好进行定制。\n\n要更改 Zsh 中的快捷键，可以使用 bindkey 命令。该命令允许用户将键位绑定到特定的操作或函数上。\n\n例如，要将 Ctrl + u 绑定到向上删除整行的操作，可以执行以下命令：\n\n```bash\nbindkey '^u' backward-kill-line\n```\n这将使得在输入命令时，按下 Ctrl + u 将会删除当前光标位置到行首的所有字符。\n\n此外，用户还可以通过编辑 .zshrc 文件来永久更改键位绑定。在文件中添加类似下面的行：\n\n```bash\nbindkey '^u' backward-kill-line\n```\n这样，每次启动 Zsh 时，Ctrl + u 都会绑定到相应的操作上。\n\n```bash\nbindkey '^[l' down-case-word\n```\n这将使得在输入命令时，按下 Alt + l 将会向前移动一个单词。\n\n通过更改 Zsh 中的快捷键，用户可以根据自己的喜好和习惯来提高在命令行界面中的操作效率，使得命令行使用更加流畅。\n","tags":["zsh"]},{"title":"GH60键盘","url":"/2024/01/18/2024-01-18/","content":"\n\nGH60是一个开源的键盘方案，有许多的外壳和pcb可以选择。又因为pcb适配了多种配列，这样又可以基于GH60衍生处很多不同配列方案，比如HHKB\n\n## HHKB布局\n需要购买额外的增补键帽\n\n7X 空格键盘 1个  \n1.5X 按键R1高度 2个  \n1.75X 按键一个R1高度 1个  \n1X 按键R1高度 3个  \n1X 按键R4高度 2个  \n\n## 相关资源\n[适配gh60pcb的外壳](https://gitee.com/tangp1n/the-key-board-01)  \n[机械键盘方案](https://github.com/help-14/mechanical-keyboard)\n","tags":["硬件"]},{"title":"vscode中的eslint与项目中的eslint","url":"/2023/11/04/2023-11-04/","content":"\n这是上一篇文章的兄弟篇，用来介绍vscode中的prettier。\n\n和prettier不同，vscode并没有内置针对javascript的lint工具。但是对于强类型的typescript来说，\nvscode就可以进行错误检查。对于弱类型的javascript来说，需要单独的配置lint工具。\n\nvscode的eslint插件主页是这么说的：\n> 这个扩展使用在打开的工作区的ESLint库。如果工作区没有提供任何版本的ESLint，那么插件会查找全局安装的版本。\n> 如果你的本地和全局都没有安装ESLint，使用npm install eslint在本地安装或者npm install eslint -g在\n> 全局安装。\n\n根据介绍，eslint扩展必须依赖eslint库才能运行。不像prettier扩展，安装后就能直接运行。\n\n在我们使用eslint库时，往往是作为命令行工具来使用。通过vscode集成，我们可以很方便的在\n编辑器上实时的看到错误信息，这便是vscode扩展的作用。vscode通过eslint扩展，将eslint库\n的输入显示在代码上，这样你便可以知道代码上的错误","tags":["VSCode"]},{"title":"C公司二面","url":"/2023/11/03/2023-11-03/","content":"\n> 进入二面之后，基础的问题问得少了，更多的是偏向实际应用，考察的更多\n> 是经验方面，以及问题的解决能力。基本上是就着简历上的项目经验来问的。\n\n1. 图怎么判断有环\n2. 讲讲你封装的表格组件\n3. JSON文件如何校验（JSON scheme）\n4. webpack的插件机制了解过吗\n5. 如何设计自己的插件机制\n6. 前端的协作系统应该怎么设计（通信协议方面）\n7. SPA应用index.html的缓存问题\n8. 缓存了解过吗 nginx怎么配缓存\n9. 微服务有了解过吗\n10. 前端的发展趋势"},{"title":"vscode中的prettier与项目中的prettier","url":"/2023/11/01/2023-11-01/","content":"\n记得刚开始学习前端的时候，vscode的配置都是网上找找抄抄，尤其是vscode插件的配置。\n一些增强vscode的自身的插件开箱即用，稍微配置一下就行。但是和项目相关的一些插件比如\nprettier、eslint这些，只是抄了配置，却不懂其中的原理。当自己改的时候就会碰的一头灰。\n\n今天，就从vscode的配置prettier出发，重新学习prettier的配置。\n\nprettier本身是一个命令行工具，提供了一些命令来格式化代码。vscode的插件在项目中没有安装prettier\n也能格式化代码的原因就是插件本身带有prettier插件。\n\n而我们在项目中安装的prettier包则是为了配合npm命令来使用。\n\n需要明确的一点是，vscode的prettier插件和项目中的prettier包是两个独立的插件。彼此之间\n没有必须依赖的关系。如果只是为了格式化代码，你可以只安装vscode的prettier插件。vscode的prettier\n插件会根据如下的配置优先级来格式化代码：\n\n1. prettier 配置文件\n2. .editorconfig\n3. vscode的配置\n\n注意，如果项目本地有任何的配置文件，那么vscode的配置则不会被使用\n\nvscode本身也提供了代码格式化功能，这个功能主要是通过配置vscode的formatter来实现的。\n当你在vscode中安装了prettier插件，则自动注册了prettier这个formatter。这样，你就\n可以在vscode中使用prettier了。\n\n如果在使用eslint和prettier配置的时候规则冲突了，按照prettier官方的推荐，可以安装eslint-prettier-config插件\n\n```bash\nnpm install --save-dev eslint-prettier-config\n```\n\n并配置eslint\n```json\n{\n  \"extends\": [\n    \"some-other-config-you-use\",\n    \"prettier\"\n  ]\n}\n```\n\n这样，便可以关闭掉所有有冲突的规则。","tags":["VSCode"]},{"title":"记一次面试","url":"/2023/10/28/2023-10-28/","content":"\n> \"信任是一种奢侈品，它不是通过钱来获得的，而是通过行为来赢得的。\" - 奥普拉·温弗瑞（Oprah Winfrey）\n\n时隔一年半，又开始面试了。面试的过程有种似曾相识但又有违和感。不知道是社会阅历的增加还是自身的处事原则变得更加圆滑，对于线下面试的感觉和之前不一样了。\n\n面试了三轮，下午就拿到了offer，虽然我也不打算去。也不是太容易得到的东西不懂得珍惜，而是这个公司给我的感觉和之前的公司一样--难以建立信任。\n\n首先是面试的侧重点，三轮面试的面试官都问了加班的问题，我也不是反对加班，只是工作日的加班没有调休也没有加班费，就周末有调休，这不就是免费义工嘛。其次是和技术相关的面试和笔试。都2023年了，怎么还在问CSS3和HTML5的新特性啊。2011年浏览器厂商全面适配CSS3，而2014年，浏览器全面适配HTML5。这快10年的时间里，前端开发者都已经把新特性融于了日常开发，谁会区分新版和旧版。\n\n大部分的面试题和笔试题也是API相关的，算是比较基础的八股文。岗位是空缺才招的，也只是想招一个写代码。\n\n最后，说好的工资为什么是加上补贴后才达到啊，还说什么福利补贴，离谱。\n\n关于为什么会被发offer，只能是因为我要的低了，钱少愿意加班，这样的人谁不要啊。\n\n这次也得到了教训，以后的HR面有更多的东西要问了：\n1. 薪资构成\n2. 公积金缴费比例和额度\n3. 社保缴费比例和额度\n4. 季度奖金 年度奖金（年终奖）\n","tags":["思考"]},{"title":"A公司笔试","url":"/2023/10/26/2023-10-26/","content":"\n1. position: fixed 一定是相对于浏览器窗口进行定位吗？\n2. js中数组是如何在内存中存储的？\n3. 实现一个深拷贝函数 deepClone。\n4. 实现 Promise.all\n5. 一个整数数组中的元素有正有负，在该数组中找出一个连续子数组，要求该连续子数组中各元素的和最大，这个连续子数组便被称作最大连续子数组。比如数组[2,4,-7,5,2,-1,2,-4,3]的最大连续子数组为[5,2,-1,2]，最大连续子数组的和为5+2-1+2=8。请实现这个函数MaxSubsequence，使得输入为一个数组，输出为该数组的最大连续子数组和最大和。\n6. 还有几道js运行结果相关的题目，设计事件循环、块级作用域","tags":["面试"]},{"title":"B公司笔试","url":"/2023/10/26/2023-10-27/","content":"\n1. vue-router生命周期\n2. v-if和v-for为什么不能一起使用\n3. \n4. 实现 Promise.all\n5. 一个整数数组中的元素有正有负，在该数组中找出一个连续子数组，要求该连续子数组中各元素的和最大，这个连续子数组便被称作最大连续子数组。比如数组[2,4,-7,5,2,-1,2,-4,3]的最大连续子数组为[5,2,-1,2]，最大连续子数组的和为5+2-1+2=8。请实现这个函数MaxSubsequence，使得输入为一个数组，输出为该数组的最大连续子数组和最大和。\n6. 还有几道js运行结果相关的题目，设计事件循环、块级作用域","tags":["面试"]},{"title":"CRUD配置工具 起因","url":"/2023/09/01/2023-09-01/","content":"\n在我们日常的工作（CRUD）中，对一部分资源的增删改查都是在一个页面或者说一个组件内完成。而这个页面一般包括搜索、添加、修改、删除、分页查询。其中，搜索一般还涉及到模糊匹配。\n\n当我们对于新来的需求，一般也是CRUD。勤快的，将这一系列业务封装成组件。虽然组件的使用一般仅限组件开发者本人，在开发者离职或者因为其他的原因不维护之后，其他人也就不会再使用这个组件了。懒一点的，一般都是直接复制相似业务的代码，然后再改一改，等到下次有类似的需求的时候再复制一次。这两种情况都会导致项目中的代码文件越来越多，也越来越难以维护。当到了某个节点，项目负责人或者谁大手一挥，说进行项目重构，你可千万不要高兴的太早，以为不要维护老系统了。大多数情况下，老的项目如果还在跑，就需要有人来维护。这个时候需要维护的数量只会多，不会少。如果项目人员变更得勤快一点，有的时候为了偷懒，直接将旧项目的代码拷贝进新项目。当然，如果有严格的代码审查一般是不会发生这种情况的，但是一般的小公司都疲于业务，代码能跑就行。\n\n作为CRUD工程师也工作了四年多了，面对一些相似的需求我也想过很多。一开始是从react的某个组件得到了灵感，将CRUD的\n这四个操作作为对象封装，使用JSON来配置表格。但是这样仅能满足一些基本的查询需求。更进一步的，如果嫌JSON麻烦，\n可以使用可视化来配置。这也是我接下来要开展的工作。","tags":["FE"]},{"title":"CRUD配置工具 设计","url":"/2023/09/01/2023-09-08/","tags":["FE"]},{"title":"用户凭证加密","url":"/2023/09/01/2024-12-17/","content":"\n在当今数字化时代，用户凭证的安全保护变得至关重要。用户凭证通常包含敏感信息，如用户名、密码、电子邮件地址等，一旦泄露，可能导致严重的安全问题。因此，对用户凭证进行加密保护变得尤为重要。\n\n本文将介绍用户凭证加密的基本概念、方法和工具，并重点探讨在 Node.js 环境下如何安全有效地处理加密凭证。\n\n**什么是用户凭证加密？**\n\n用户凭证加密是指使用加密算法对用户凭证进行加密，使其无法被未授权者读取或篡改。加密后的凭证通常以密文形式存储，只有拥有正确解密密钥的人才能解密并访问其中的信息。\n\n**用户凭证加密的方法**\n\n用户凭证加密可以使用多种方法，包括对称加密、非对称加密和哈希加密。\n\n* **对称加密**：对称加密使用相同的密钥进行加密和解密。常见的对称加密算法包括 AES、DES 和 3DES。AES (高级加密标准) 是目前最常用的对称加密算法，安全性高，效率好。\n* **非对称加密**：非对称加密使用一对密钥进行加密和解密。公钥用于加密，私钥用于解密。常见的非对称加密算法包括 RSA 和 ECC。非对称加密算法安全性高，适用于密钥交换、数字签名等场景。\n* **哈希加密**：哈希加密是一种单向加密算法，无法从密文还原出明文。常见的哈希加密算法包括 MD5（不推荐使用，因为存在安全漏洞）、SHA-1（也不推荐使用） 和 SHA-256、SHA-512 (推荐使用)。哈希加密算法常用于存储密码，验证数据的完整性和真实性。\n\n**Node.js 中处理加密凭证**\n\nNode.js 提供了 `crypto` 模块，用于进行各种加密操作。以下是一些在 Node.js 中处理加密凭证的常用方法和最佳实践：\n\n**1. 使用安全的对称加密算法 (AES-256-GCM)：**\n\n相比 CBC 模式，GCM（伽罗瓦/计数器模式）提供了认证加密，可以同时保证数据的机密性和完整性。以下是一个使用 `aes-256-gcm` 的示例：\n\n```javascript\nimport crypto from 'crypto';\n\nconst ENCRYPTION_KEY = process.env.ENCRYPTION_KEY; // 强烈建议从环境变量或密钥管理服务中获取密钥\n\nfunction encryptGCM(data, aad) {\n    if (!ENCRYPTION_KEY) throw new Error('ENCRYPTION_KEY is not set');\n    const key = Buffer.from(ENCRYPTION_KEY, 'hex'); // 密钥需要转换为 Buffer\n    const iv = crypto.randomBytes(12); // GCM 推荐 12 字节 IV\n    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\n    if (aad) {\n        cipher.setAAD(Buffer.from(aad));\n    }\n    const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);\n    const authTag = cipher.getAuthTag();\n    return {\n        iv: iv.toString('hex'),\n        encryptedData: encrypted.toString('hex'),\n        authTag: authTag.toString('hex')\n    };\n}\n\nfunction decryptGCM(encryptedData, aad) {\n    if (!ENCRYPTION_KEY) throw new Error('ENCRYPTION_KEY is not set');\n    const key = Buffer.from(ENCRYPTION_KEY, 'hex');\n    const iv = Buffer.from(encryptedData.iv, 'hex');\n    const authTag = Buffer.from(encryptedData.authTag, 'hex');\n    const encrypted = Buffer.from(encryptedData.encryptedData, 'hex');\n\n    const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);\n    if (aad) {\n      decipher.setAAD(Buffer.from(aad));\n    }\n    decipher.setAuthTag(authTag);\n    try {\n        const decrypted = Buffer.concat([decipher.update(encrypted), decipher.final()]);\n        return decrypted.toString();\n    } catch (error) {\n        // 认证失败，数据可能被篡改\n        return null;\n    }\n}\n\n// 使用示例\nconst message = 'This is a secret message.';\nconst associatedData = 'additional data';\n\nconst encrypted = encryptGCM(message, associatedData);\nconst decrypted = decryptGCM(encrypted, associatedData);\n```\n\n**2. 安全地存储密码 (使用 bcrypt 或 Argon2):**\n\n永远不要以明文形式存储密码。使用 bcrypt 或 Argon2 这样的密钥导出函数（KDF）进行哈希加盐处理。这些算法计算强度高，可以有效抵抗彩虹表攻击。\n\n```javascript\nimport bcrypt from 'bcrypt'; // 或使用 argon2\n\nasync function hashPassword(password) {\n  const saltRounds = 10; // 成本因子，越高越安全，但速度越慢\n  const hashedPassword = await bcrypt.hash(password, saltRounds);\n  return hashedPassword;\n}\n\nasync function comparePassword(password, hashedPassword) {\n  const match = await bcrypt.compare(password, hashedPassword);\n  return match;\n}\n\n// 使用示例\nconst password = 'mysecretpassword';\nconst hashedPassword = await hashPassword(password);\nconst isMatch = await comparePassword(password, hashedPassword);\n```\n\n**3. 密钥管理：**\n\n* **环境变量：** 对于简单的应用，可以使用环境变量存储密钥，但要确保服务器环境的安全。\n* **密钥管理服务 (KMS):** 对于生产环境，强烈建议使用专业的密钥管理服务，如 AWS KMS、Google Cloud KMS 或 HashiCorp Vault。这些服务提供了安全的密钥存储、轮换和访问控制。\n* **绝不硬编码密钥：** 不要将密钥直接写在代码中。\n\n**4. 使用 HTTPS：**\n\n使用 HTTPS 协议进行所有通信，以确保数据在传输过程中的安全。\n\n**用户凭证加密的工具**\n\n除了 Node.js 的 `crypto` 模块和 bcrypt/Argon2 库之外，还有其他一些有用的工具和库：\n\n* **dotenv:** 用于从 `.env` 文件加载环境变量。\n* **config:** 用于管理应用程序的配置，包括敏感信息。\n\n**用户凭证加密的作用**\n\n用户凭证加密可以保护用户隐私和安全，防止用户凭证被盗窃、泄露或篡改。用户凭证加密还可以防止用户凭证被恶意使用。\n\n**用户凭证加密的注意事项**\n\n* **选择安全的加密算法**：优先选择经过广泛审查和推荐的算法，如 AES-256-GCM、bcrypt 或 Argon2。\n* **使用强密码**：强制用户使用强密码，并实施密码策略。\n* **定期备份加密数据和密钥**：但要确保备份的安全性。\n* **定期审查和更新加密方案**：关注最新的安全漏洞和最佳实践，并及时更新加密方案。\n\n**总结**\n\n用户凭证加密是保护用户数据安全的重要基石。在 Node.js 环境中，通过结合 `crypto` 模块、bcrypt/Argon2 和安全的密钥管理实践，可以构建强大的用户凭证保护机制。希望本文能够帮助开发者更好地理解和应用用户凭证加密技术。\n\n这个版本添加了更多关于 Node.js 加密最佳实践的细节，包括使用 `aes-256-gcm`、bcrypt/Argon2 进行密码哈希、密钥管理以及其他有用的工具。它也更强调了安全的重要性，并提供了更全面的建议。\n\n","tags":["Node.js"]},{"title":"提取和安全裂变","url":"/2023/07/22/2023-07-22/","content":"\n# 提取\n\nUnoCSS通过在代码库中搜索工具的使用情况，并根据需求生成相应的CSS。我们将这个过程称为提取（extracting）。\n\n## 内容来源\n\nUnoCSS支持从多个来源提取工具的使用情况：\n\n- [Pipeline](https://unocss.dev/guide/extracting#extracting-from-build-tools-pipeline) -- 从您的构建工具流程中提取正确的部分\n- [Filesystem](https://unocss.dev/guide/extracting#extracting-from-filesystem) -- 通过读取和监视文件从您的文件系统中提取\n- [inline](https://unocss.dev/guide/extracting#extracting-from-inline-text) -- 从内联的纯文本中提取\n\n来自不同来源的工具使用情况将被合并在一起，并生成最终的CSS。\n\n### 从构建工具流程中提取内容\n\n这在 Vite 和 Webpack 的集成中得到支持。\n\nUnoCSS将读取通过构建工具流程的内容，并从中提取工具的使用情况。这是最高效和准确的提取方式，因为我们只智能提取实际在您的应用程序中使用的工具使用情况，并且在提取过程中不进行额外的文件IO操作。\n\n默认情况下，UnoCSS将从构建流程中的具有扩展名 .jsx、.tsx、.vue、.md、.html、.svelte、.astro 的文件中提取工具的使用情况，并根据需要生成相应的CSS。默认情况下，不包括 .js 和 .ts 文件。\n\n要进行配置，您可以更新您的 uno.config.ts 文件：\n\n```typescript\n// uno.config.ts\nexport default defineConfig({\n  content: {\n    pipeline: {\n      include: [\n        // the default\n        /\\.(vue|svelte|[jt]sx|mdx?|astro|elm|php|phtml|html)($|\\?)/,\n        // include js/ts files\n        'src/**/*.{js,ts}',\n      ],\n      // exclude files\n      // exclude: []\n    }\n  }\n})\n```\n\n您还可以在文件中的任何位置添加 @unocss-include 魔术注释，以文件为基础，告诉 UnoCSS 扫描该文件。或者，在配置中添加 *.js 或 *.ts，以将所有 js/ts 文件包括在扫描目标中。\n\n```javascript\n// ./some-utils.js\n\n// since `.js` files are not included by default,\n// the following comment tells UnoCSS to force scan this file.\n// @unocss-include\nexport const classes = {\n  active: 'bg-primary text-white',\n  inactive: 'bg-gray-200 text-gray-500',\n}\n```\n\n类似地，您还可以添加 @unocss-ignore 来跳过对文件的扫描和转换。\n\n如果您希望 UnoCSS 跳过某个代码块而不进行提取，您可以使用成对的 @unocss-skip-start 和 @unocss-skip-end 来实现：\n\n```html\n<p class=\"text-green text-xl\">\n  Green Large\n</p>\n\n<!-- @unocss-skip-start -->\n<!-- `text-red` will not be extracted -->\n<p class=\"text-red\">\n  Red\n</p>\n<!-- @unocss-skip-end -->\n```\n\n### 从文件系统中提取\n在某些情况下，如果您使用的集成没有访问构建工具流程（例如，PostCSS 插件），或者您正在与后端框架进行集成且代码不经过构建流程，您可以手动指定要提取的文件。\n\n```typescript\n// uno.config.ts\nexport default defineConfig({\n  content: {\n    filesystem: [\n      'src/**/*.php',\n      'public/*.html',\n    ]\n  }\n})\n```\n匹配的文件将直接从文件系统中读取，并在开发模式下进行更改监视。\n\n### 从内联文本中提取\n\n此外，您还可以从内联文本中提取工具的使用情况，这些文本可能来自其他地方。\n\n您还可以传递一个异步函数来返回内容。但请注意，该函数只会在构建时调用一次。\n\n```typescript\n// uno.config.ts\nexport default defineConfig({\n  content: {\n    inline: [\n      // plain text\n      '<div class=\"p-4 text-red\">Some text</div>',\n      // async getter\n      async () => {\n        const response = await fetch('https://example.com')\n        return response.text()\n      }\n    ]\n  }\n})\n```\n\n## 局限性\n\n由于 UnoCSS 在构建时运行，这意味着只有静态呈现的工具才会生成并传递到您的应用程序中。在运行时动态使用或从外部资源获取的工具可能不会被应用。\n\n### 安全列表\n有时您可能希望使用动态的拼接，例如：\n```html\n<div class=\"p-${size}\"></div> <!-- this won't work! -->\n```\n由于 UnoCSS 在构建时使用静态提取，我们无法在编译时知道所有工具的组合情况。因此，您可以配置 safelist 选项来解决这个问题。\n\n```typescript\n// uno.config.ts\nsafelist: 'p-1 p-2 p-3 p-4'.split(' ')\n```\n生成对应的 CSS：\n```css\n.p-1 { padding: 0.25rem; }\n.p-2 { padding: 0.5rem; }\n.p-3 { padding: 0.75rem; }\n.p-4 { padding: 1rem; }\n```\n\n或者更灵活：\n```typescript\n// uno.config.ts\nsafelist: [\n  ...Array.from({ length: 4 }, (_, i) => `p-${i + 1}`),\n]\n```\n\n如果您希望在运行时进行真正的动态生成，您可以查看 @unocss/runtime 包\n\n### 黑名单\n\n类似于 safelist，您还可以配置 blocklist 来排除某些工具的生成。不同于 safelist，blocklist 接受字符串进行精确匹配和正则表达式进行模式匹配。\n\n```typescript\n// uno.config.ts\nblocklist: [\n  'p-1',\n  /^p-[2-4]$/,\n]\n```\n这将排除 p-1、p-2、p-3 和 p-4 的生成。这对于排除一些误报非常有用。","tags":["FE","翻译","UnoCSS"]},{"title":"配置文件","url":"/2023/07/16/2023-07-16/","content":"\n# 配置文件\n\n我们强烈建议使用一个专门的 uno.config.ts 文件来配置您的 UnoCSS，以便在使用集成开发环境（IDE）和其他集成工具时获得最佳体验。\n\n一个完整的配置文件示例如下：\n\n```typescript\n// uno.config.ts\nimport {\n  defineConfig,\n  presetAttributify,\n  presetIcons,\n  presetTypography,\n  presetUno,\n  presetWebFonts,\n  transformerDirectives,\n  transformerVariantGroup\n} from 'unocss'\n\nexport default defineConfig({\n  shortcuts: [\n    // ...\n  ],\n  theme: {\n    colors: {\n      // ...\n    }\n  },\n  presets: [\n    presetUno(),\n    presetAttributify(),\n    presetIcons(),\n    presetTypography(),\n    presetWebFonts({\n      fonts: {\n        // ...\n      },\n    }),\n  ],\n  transformers: [\n    transformerDirectives(),\n    transformerVariantGroup(),\n  ],\n})\n```\n\n与位于 vite.config.ts 或其他工具配置文件内部的内联配置相比，专用的配置文件在与 IDE 和其他工具（如 ESLint 插件）的集成方面效果更好，并且可以更好地支持热模块重载（HMR）。\n\n默认情况下，UnoCSS 会自动在项目的根目录中查找 uno.config.{js,ts,mjs,mts} 或 unocss.config.{js,ts,mjs,mts} 文件。你也可以手动指定配置文件，例如在 Vite 中：\n\n```typescript\n// vite.config.ts\nimport { defineConfig } from 'vite'\nimport UnoCSS from 'unocss/vite'\n\nexport default defineConfig({\n  plugins: [\n    UnoCSS({\n      configFile: '../my-uno.config.ts',\n    })\n  ]\n})\n```\n有关支持的配置选项的完整列表，请参考配置[参考文档](https://unocss.dev/config/)。","tags":["FE","翻译","UnoCSS"]},{"title":"page","url":"/2023/07/15/2023-07-15/","content":"\n# 浏览器样式重置\n\nUnoCSS默认不提供样式重置或预设样式，以提供最大的灵活性，并且不会填充全局CSS。如果您与其他CSS框架一起使用UnoCSS，它们可能已经为您进行了样式重置。如果您仅使用UnoCSS，您可以使用类似Normalize.css的重置库。\n\n## 安装\n我们还提供了一个小型集合，供您快速获取它们：\n\n```bash\n# pnpm\npnpm add @unocss/reset\n# yarn\nyarn add @unocss/reset\n# npm\nnpm install @unocss/reset\n```\n\n## 使用\n您可以将以下重置样式表之一添加到您的 main.js 文件中：\n\n### normalize.css\n源代码：https://github.com/csstools/normalize.css\n\n```typescript\nimport '@unocss/reset/normalize.css'\n```\n\n### sanitize.css\n源代码：https://github.com/csstools/sanitize.css\n```typescript\nimport '@unocss/reset/sanitize/sanitize.css'\nimport '@unocss/reset/sanitize/assets.css'\n```\n### Eric Meyer\n源代码：https://meyerweb.com/eric/tools/css/reset/index.html\n```typescript\nimport '@unocss/reset/eric-meyer.css'\n```\n### Tailwind\n```typescript\nimport '@unocss/reset/tailwind.css'\n```\n### Tailwind compat\n```typescript\nimport '@unocss/reset/tailwind-compat.css'\n```","tags":["FE","翻译","UnoCSS"]},{"title":"UnoCSS（三）预设","url":"/2023/07/12/2023-07-12/","content":"\n预设是UnoCSS的核心。它们让您可以在几分钟内创建自己的定制框架。\n\n## 使用预设\n\n在你的项目中设置预设：\n\n```typescript\n// uno.config.ts\nimport { defineConfig, presetAttributify, presetUno } from 'unocss'\n\nexport default defineConfig({\n  presets: [\n    presetAttributify({ /* preset options */}),\n    presetUno(),\n    // ...custom presets\n  ],\n})\n```\n\n如果你自己定义了presets选项，那么默认的预设就会被忽略。\n\n为了禁用默认的预设，你可以将presets设置为空数组。\n\n```typescript\n// uno.config.ts\nimport { defineConfig } from 'unocss'\n\nexport default defineConfig({\n  presets: [], // disable default preset\n  rules: [\n    // your custom rules\n  ],\n})\n```\n\n您可以查看[官方预设](https://unocss.dev/presets/)和[社区预设](https://unocss.dev/presets/community)以获取更多信息。\n\n## 创建预设\n要了解如何创建自己的自定义预设，请参阅配置：[预设部分](https://unocss.dev/config/presets)。","tags":["FE","翻译","UnoCSS"]},{"title":"UnoCSS（二）为什么是UnoCSS","url":"/2023/07/10/2023-07-10/","content":"\n> 本篇博客翻译自[Why UnoCSS](https://unocss.dev/why/)\n\n# 动机\n\n我们建议您阅读UnoCSS的创建者[Anthony Fu](https://antfu.me/)撰写的博客文章[《重新构想原子CSS》](https://antfu.me/posts/reimagine-atomic-css)，以更好地了解UnoCSS背后的动机。\n\n# UnoCSS与X之间的不同\n\n## Windi CSS\n\nUnoCSS是由Windi CSS团队的一名成员发起的，从我们在Windi CSS中的工作中获得了很多灵感。虽然Windi CSS自2023年3月起不再积极维护，但您可以将UnoCSS视为Windi CSS的“精神继承者”。\n\nUnoCSS继承了Windi CSS的按需加载、属性模式、快捷方式、变体组、编译模式等特性。此外，UnoCSS是从头开始构建的，以最大的可扩展性和性能为目标，使我们能够引入新功能，如纯CSS图标、无值属性模式、标签模式、Web字体等。\n\n最重要的是，UnoCSS被提取为一个原子CSS引擎，其中所有功能都是可选的，使您能够轻松创建自己的约定、设计系统和预设 - 并结合您想要的功能组合。\n\n## Tailwind CSS\n\nBoth Windi CSS和UnoCSS都从Tailwind CSS中获得了很多灵感。由于UnoCSS是从头开始构建的，我们能够全面了解原子CSS是如何通过前期工作进行设计，并将其抽象为一个优雅而强大的API。由于设计目标有很大的不同，所以与Tailwind CSS进行直接的苹果对苹果比较并不太合适。但是我们将尝试列出一些区别：\n\nTailwind CSS是一个PostCSS插件，而UnoCSS是一个具有一堆与构建工具的一流集成（包括一个PostCSS插件）的同构引擎。这意味着UnoCSS可以更加灵活地在不同的地方使用（例如在运行时生成CSS的CDN Runtime），并与构建工具深度集成，以提供更好的HMR、性能和开发者体验（例如，检查器）。\n\n除了技术上的取舍之外，UnoCSS还被设计为完全可扩展和可定制，而Tailwind CSS则更具有明确的意见。在Tailwind CSS之上构建自定义设计系统（或设计令牌）可能会很困难，并且您不能真正摆脱Tailwind CSS的约定。而使用UnoCSS，您可以完全控制地构建几乎任何您想要的东西。例如，我们在一个预设中实现了整个与Tailwind CSS兼容的实用工具集，而且还有许多令人惊叹的社区预设实现了其他有趣的哲学。\n\n由于UnoCSS提供的灵活性，我们能够在其之上尝试许多创新功能，例如：\n\n- [纯CSS图标](https://unocss.dev/presets/icons)\n- [Attributify Mode](https://unocss.dev/presets/attributify)\n\n为了使其更具灵活怼您可以逿将规则的第一ª参数（我们称之为匹配器）更改为正则表达式，并将其主体更改为函数来使规则变得动怌，例如：\n\n```typescript\n// uno.config.ts\nexport default defineConfig({\n      rules: [\n      -    ['m-1', { margin: '1px' }]\n      +    [/^m-([\\.\\d]+)$/, ([_, num]) => ({ margin: `${num}px` })],\n        ],\n})\n```\n逿这样做，现在您可以拥有任意的边距实用工具，例如m-1ã100或m-52.43　¸，UnoCSS只在您使用它们时才会生成相应的样式ã```html\n<div class=\"m-1\">Hello</div>\n<div class=\"m-7.5\">World</div>\n```\n\n```css\n```\n- [Variant Groups](https://unocss.dev/transformers/variant-group)\n- [Shortcuts](https://unocss.dev/config/shortcuts)\n- [Tagify](https://unocss.dev/presets/tagify)\n- [Web fonts](https://unocss.dev/presets/web-fonts)\n- [CDN Runtime](https://unocss.dev/integrations/runtime)\n- [Inspector](https://unocss.dev/tools/inspector)\n  \nUnoCSS确实不支持Tailwind CSS的插件系统或配置，这意味着从一个定制程度很高的Tailwind CSS项目迁移到UnoCSS可能会更加困难。这是为了使UnoCSS具有高性能和可扩展性而做出的有意决策，我们相信这种权衡是值得的。","tags":["FE","翻译","UnoCSS"]},{"title":"UnoCSS（一）什么是UnoCSS","url":"/2023/07/07/2023-07-07/","content":"\n> 本篇博客翻译自[UnoCSS guide](https://unocss.dev/guide/)\n\n\nUnoCSS是一个即时的原子CSS引擎，旨在具有灵活性和可扩展性。其核心是无偏见的，所有的CSS实用工具都通过预设提供。\n\n例如，你可以在本地配置文件中提供自定义规则，来定义你自己的CSS工具\n\n```typescript\n// uno.config.ts\nimport { defineConfig } from 'unocss'\n\nexport default defineConfig({\n  rules: [\n    ['m-1', { margin: '1px' }]\n  ],\n})\n```\n\n这将向您的项目添加一个新的CSS实用工具m-1。由于UnoCSS是按需加载的，只有在您在代码库中使用它时才会生效。假设我们有一个如下的组件：\n\n```html\n<div class=\"m-1\">Hello</div>\n```\n\nm-1将被检测到，并生成以下的CSS代码：\n\n```css\n.m-1 { margin: 1px; }\n```\n\n为了使其更具灵活性，您可以通过将规则的第一个参数（我们称之为匹配器）更改为正则表达式，并将其主体更改为函数来使规则变得动态化，例如：\n\n```typescript\n// uno.config.ts\nexport default defineConfig({\n  rules: [\n-    ['m-1', { margin: '1px' }]\n+    [/^m-([\\.\\d]+)$/, ([_, num]) => ({ margin: `${num}px` })],\n  ],\n})\n```\n通过这样做，现在您可以拥有任意的边距实用工具，例如m-1、m-100或m-52.43。而且，UnoCSS只在您使用它们时才会生成相应的样式。\n\n```html\n<div class=\"m-1\">Hello</div>\n<div class=\"m-7.5\">World</div>\n```\n\n```css\n.m-1 { margin: 1px; }\n.m-7.5 { margin: 7.5px; }\n```\n\n# 预设\n一旦您创建了一些规则，您可以将它们提取到一个预设中，并与他人分享。例如，您可以为您公司的设计系统创建一个预设，并与团队共享。\n\n```typescript\n// my-preset.ts\nimport { Preset } from 'unocss'\n\nexport const myPreset: Preset = {\n  name: 'my-preset',\n  rules: [\n    [/^m-([\\.\\d]+)$/, ([_, num]) => ({ margin: `${num}px` })],\n    [/^p-([\\.\\d]+)$/, ([_, num]) => ({ padding: `${num}px` })],\n  ],\n  variants: [/* ... */],\n  shortcuts: [/* ... */]\n  // ...\n}\n```\n\n```typescript\n// uno.config.ts\nimport { defineConfig } from 'unocss'\nimport { myPreset } from './my-preset'\n\nexport default defineConfig({\n  presets: [\n    myPreset // your own preset\n  ],\n})\n```\n同样地，我们提供了一些[官方预设](https://unocss.dev/presets/)供您立即开始使用，并且您还可以找到许多有趣的[社区预设](https://unocss.dev/presets/community)。","tags":["FE","翻译","UnoCSS"]},{"title":"工具收集","url":"/2023/03/16/2023-03-16/","content":"\n从拥有自己的第一台电脑开始已经过了 11 年了，经历了 Windows7 8 10 11 这么多版本的更新，也一直在使用一些工具。\n有些工具自己就是一个平台，有着与其对应的使用习惯和插件或应用市场。\n\n## Windows\n\n| 名称             | 描述                     |\n| ---------------- | ------------------------ |\n| Chrome           | 浏览器老大               |\n| VSCode           | 吃饭的家伙               |\n| NeoVim           | 解放鼠标                 |\n| Ditto            | 剪切板管理               |\n| Everything       | 强大的搜索，发现一切     |\n| Zeal             | 文档工具                 |\n| Draw.io          | 画图工具，可以制作脑图   |\n| Powertoys        | 微软出品，使用工具集合   |\n| Windows Terminal | 好用的终端工具，微软出品 |\n| WSL              | 离不开了                 |\n| Insomnia         | 接口测试                 |\n| SumatraPDF       | 轻量 pdf 阅读器          |\n| Notepad2-mod     | nodepad 的替代           |\n\n## Chrome 插件\n\nChrome 已经变成事实意义上的浏览器标准了。服务端也有源自 ChromeV8 的 Node.js，客户端还有 Electron。\n\n| 名称               | 描述                          |\n| ------------------ | ----------------------------- |\n| Proxy SwitchyOmega | 科学上网必备                  |\n| Vimium             | 使用 Vim 快捷键导航，解放鼠标 |\n| Vue.js devtools    | 吃饭的家伙+1                  |\n| 沙拉查词           | 换了不知道多少个了            |\n| Tampermonkey       | 油猴插件                      |\n| FeHelper           | 前端开发工具合集              |\n| Bitwarden          | 密码保管                      |\n\n广告插件经常换，一个没用就装两个，总有一个有用\n","tags":["工具"]},{"title":"你了解Webpack的Source Map吗","url":"/2023/02/11/2023-02-11/","content":"\n在前端开发中，调试和排除错误是一个关键的环节。Webpack作为一个强大的打包工具，它提供了一项重要功能，即Source Map（源代码映射）。本文将深入探讨Webpack中Source Map的作用、工作原理以及如何在项目中使用它来提升开发效率和调试体验。\n\n## Source Map是什么？\n\nSource Map是一种文件，它存储了打包后的代码与原始源代码之间的映射关系。它允许开发人员在调试阶段轻松地将打包后的代码映射回原始源代码，从而更容易地定位和解决问题。\n\n## Webpack中的Source Map\n\nWebpack提供了多种类型的Source Map选项，可以根据需要进行配置。其中一些常见的选项包括：\n\n- eval：通过eval函数执行代码，并且生成的Source Map将会以DataUrl的形式嵌入到打包后的文件中。\n- cheap：仅定位行信息，不包含列信息。\n- module：包含loader的sourcemap。\n\n## Source Map的作用\n\n使用Webpack的Source Map有以下几个重要的作用：\n\n1. **调试：** Source Map可以帮助开发人员在浏览器中准确定位错误和异常，从而更快地调试和修复问题。\n2. **优化：** 在生产环境中，Source Map可以帮助开发人员识别和优化代码，提高代码质量和性能。\n3. **保护代码：** Source Map允许开发人员在不暴露源代码的情况下进行调试和排查问题，保护了代码的安全性。\n\n## 如何配置Webpack的Source Map\n\n在Webpack配置文件中，可以通过以下方式启用Source Map：\n\n```javascript\nmodule.exports = {\n  // ...\n  devtool: 'source-map',\n  // ...\n};\n```\n\n此外，Webpack还支持其他不同类型的Source Map选项，可以根据项目的具体需求进行配置。\n\n## 结论\n\n在本文中，我们详细探讨了Webpack中Source Map的作用、工作原理以及如何在项目中进行配置。通过合理地配置和使用Source Map，开发人员可以更加高效地调试和优化代码，提高开发效率和代码质量。希望本文能够帮助读者更好地理解和应用Webpack中的Source Map功能。","tags":["面试"]},{"title":"http2相比于http1做了哪些升级","url":"/2023/01/07/2023-01-07/","content":"\n## HTTP/2 相比于 HTTP/1.x 做了以下升级：\n\n* **Header 压缩**：HTTP/1.x 每次请求都需要发送完整的请求头，而 HTTP/2 使用 HPACK 算法将请求头进行压缩，从而减少了传输的数据量。\n* **二进制格式**：HTTP/2 使用二进制格式来传输数据，这使得数据传输更加高效。\n* **多路复用**：HTTP/1.x 每次只能发送一个请求，而 HTTP/2 可以同时发送多个请求，从而提高了并发度。\n* **服务器推送**：HTTP/2 允许服务器在客户端请求之前就发送一些资源，从而减少了客户端的请求数量。\n* **首字节时间（TTFB）的减少**：HTTP/2 可以减少首字节时间，从而提高网页的响应速度。\n\n具体来说，HTTP/2 的升级主要体现在以下几个方面：\n\n* **效率的提高**：HTTP/2 通过 header 压缩、二进制格式、多路复用等技术，可以提高 HTTP 通信的效率，降低网络带宽的占用。\n* **性能的提升**：HTTP/2 通过服务器推送、首字节时间的减少等技术，可以提升 HTTP 通信的性能，提高网页的响应速度。\n* **安全性的增强**：HTTP/2 使用 TLS 1.2 或更高版本来加密通信，增强了 HTTP 通信的安全性。\n\nHTTP/2 的升级为 Web 应用的开发带来了许多好处，包括：\n\n* **提高了网页的响应速度**\n* **降低了网络带宽的占用**\n* **增强了 HTTP 通信的安全性**\n","tags":["面试"]},{"title":"first-of-type和last-of-type","url":"/2022/11/10/2022-11-10/","content":"<style>\n    dt {\n  font-weight: bold;\n}\n\ndd {\n  margin: 3px;\n}\n\ndd:first-of-type {\n  border: 2px solid orange;\n}\n\n</style>\n今天看代码的时候发现了两个没有使用过的伪类\n1. :fisrt-of-type\n2. :last-of-type\n\nfisrt-of-type 表示一组兄弟元素中其类型的第一个元素\n\n<dl>\n  <dt>Vegetables:</dt>\n  <dd>1. Tomatoes</dd>\n  <dd>2. Cucumbers</dd>\n  <dd>3. Mushrooms</dd>\n  <dt>Fruits:</dt>\n  <dd>4. Apples</dd>\n  <dd>5. Mangos</dd>\n  <dd>6. Pears</dd>\n  <dd>7. Oranges</dd>\n</dl>\n\n```css\ndt {\n  font-weight: bold;\n}\n\ndd {\n  margin: 3px;\n}\n\ndd:first-of-type {\n  border: 2px solid orange;\n}\n```\n\n\nlast-of-type 表示了在（它父元素的）子元素列表中，最后一个给定类型的元素\n\n多了一种用来处理一系列同标签元素首位样式的问题。","tags":["CSS"]},{"title":"Vite和Webpack的区别","url":"/2022/10/06/2023-11-06/","content":"\n\nvite以其更快的编译速度和更低的内存占用率，给前端开发带来了全新的体验，而webpack凭借其高度的自定义性和成熟的生态，仍是前端构建工具的重要选择\n\n## 构建速度\nVite在开发环境下具有更快的冷启动和热重载速度。它使用了现代浏览器的原生 ES 模块支持，通过将依赖项进行按需编译，避免了传统的打包过程，从而提高了构建速度。相比之下，Webpack在大型项目中通常需要更长的构建时间。\n\n## 开发体验\nVite支持零配置开发，只需简单的配置即可开始开发，而Webpack需要更复杂的配置。Vite还提供了基于浏览器原生模块的开发服务器，允许快速的热模块替换（HMR）和快速的重新加载，提供了更流畅的开发体验。\n\n## 生态系统\nWebpack是一个成熟的构建工具，拥有庞大的生态系统和广泛的插件支持。Vite相对较新，生态系统相对较小，但也在不断扩展中。一些常用的Webpack插件可能还没有对应的Vite插件。\n\n## 适用场景\nWebpack适用于复杂的应用程序和大型项目，可以处理各种类型的文件和资源，并提供了强大的自定义和优化选项。Vite则更适用于快速原型开发、小型项目和较简单的应用程序，特别是在需要快速冷启动和热更新的情况下。","tags":["工具"]},{"title":"页面加载优化","url":"/2022/09/01/2022-09-01/","content":"\n不同的 tab 页使用的还是同一个组件，但是在 tab 点击到列表完全展示，差不多有 1s~2s 等待时间。原因可能是组件加载缓慢或者网络请求慢\n\n### 组件加载\n\n使用 Vue devtool 可以检查组件的加载时间\n\n![](/img/20220901101039.png)\n\nlogContent 是列表组件容器，卡顿的表现也主要是由于该组件中的列表上时间没有渲染到页面，从而造成了视觉上的卡顿。从上图可以看出这个组件并没有耗费太长的时间。\n\n### 接口请求\n\n因为页面上有许多组件都可以和列表有交互,所以将数据的请求放在 Vuex 的 actions 中，可以更方便的在不同的组件中共享状态和操作。\n整个列表加载是由三个接口构成\n\n以下接口均为最近 5 分钟的查询结果 从上到下依次是三个接口的加载时间\n切换第一个 tab 时\n\n![](/img/20220901111414.png)\n\n![](/img/20220901111509.png)\n\n![](/img/20220901111613.png)\n\n三次接口查询分别耗时 613ms 607ms 39ms\n切换第二个 tab 时\n\n![](/img/20220901111430.png)\n\n![](/img/20220901111547.png)\n\n![](/img/20220901111630.png)\n\n三个接口总共耗时 802ms 831ms 790ms\n\n访问上海的数据中心时平均耗时接近 1s，接近肉眼观察的页面加载时间\n\n### 页面体验优化\n\n加载动画在列表接口请求结束后就消失了，列表加载卡顿的原因也主要来自于 loading 动画结束之后到列表加载出来后的这一空白时间。loading 动画应该在第一个接口之前开始，在最后一个接口之后结束。\n通过手动延长加载时间后，发现 loading 动画消失后到页面列表加载出来的这段时间，也是由 loading 组件占据了列表的位置，只是没有显示加载动画。\n\n![](/img/20220901114922.png)\n\nloading 状态由 noData 和 isLoadding 两个变量控制，当列表请求结束后，便设置了 noData 变量，而 isLoadding 变量还是 true，从而导致了动画结束后的空白时间。\n至此，问题也解决了，去掉组件的 show-img 属性，将 setListLoadding 提前，便可以使动画正常结束。\n\n### 组件加载顺序\n\n在调试的过程中发现，初次进入原始日志页面的时候，表头的数据加载晚于列表的数据的加载。在 Vue 中，子组件的 created 生命周期先于父组件的 created 生命周期完成。获取日志的方法在子组件 searchbox 中调用，而获取表头的接口则在父组件中调用。因此，获取表头的方法永远晚于获取日志的接口，从而导致了表头的闪烁。这个问题可以通过将列表数据的请求放在父组件中来解决\n","tags":["Vue.js"]},{"title":"NAS折腾（二）内网穿透","url":"/2022/08/15/2022-08-15/","content":"\n信息流之类的 app 一旦开始就很难停下来，例如 twitter、微博、bilibili。每天的\n闲暇时间都在不同的 app 之间切换。有没有能够聚合所有信息流的方法呢？想起之前使用的\nrss，免费的 inoreader 和 feedly 都有不同的限制，于是使用了自架 rss。\n\n## 内网穿透\n\n### 花生壳 PHTunnel\n\n内网穿透首先需要的便是公网 ip，家里的网络是中国移动的免费宽带，而小气的移动\n宽带根本就没有多少公网 ip，就得想想其他方法。有没有不需要公网 ip 也可以进行内\n网穿透的方法？在找的过程中发现花生壳 PHTunnel 就是这样的工具，而路由器自带花\n生壳插件，具体的使用方法如下\n\n1. 开启路由器自带的花生壳插件用来生成 sn 码\n2. 使用生成的 sn 码登录花生壳管理平台\n3. 花 6 元钱开启 HTTPS 映射服务\n4. 添加内网映射\n\n### zerotier\n\n1. 注册 zerotier 账号\n2. 在 zerotier 上创建网络\n3. nas/手机/电脑下载客户端\n4. ssh 到 nas\n5. 执行 zerotier network 命令\n6. 其他客户端操作类似，加入创建的网络\n\n## 加内存\n\n使用 docker 至少需要 8g 内存，而自带的只有 2g，强制开启 docker 的话肯定会卡死，闲鱼\n购买了一根 8g 的 ddr3l 的内存，这样再也不怕内存不足了\n\n## 开启 docker\n\n## 部署 tts\n\n使用 docker 部署[tts](https://ttrss.henry.wang/zh/#%E5%85%B3%E4%BA%8E)\n\n## 从 inoreader 迁移\n\n从 inoreader 平台导出 opml 文件\n\n## 手机使用\n\ntts 提供了官方安卓客户端，使用体验良好，ios 可以使用 reeder\n","tags":["硬件"]},{"title":"在VSCode中使用Neovim","url":"/2022/08/11/2022-08-11/","content":"\n在 VSCode 中配置 NeoVim 是参考的 Youtube 上的一个视频，那段视频也配有博客，后来，博客作者开发了 lunarvim，那篇博客也被删除了，视频和代码还在，现在自己记录一下配置过程\n\n## VSCode 配置\n\n### 插件\n\nVSCode Neovim\nWhich Key\n\n## Neovim 配置\n","tags":["VSCode","Vim"]},{"title":"大公司与小公司","url":"/2022/06/04/2022-06-04/","content":"\n> 转自寝取的史官的微博\n\n小公司和大公司拼人力必然是处于劣势，小公司难招\n人，更难留人，尤其是面对大公司砸钱的时候。但小\n公司也不是没有办法留人，除了钱和镀金简历，小公\n司也可以拿出大公司没有或很难给出的体验。\n\n在钱方面，拼绝对值肯定不是大公司的对手，但只要\n不是差出太多就能从其他方面掰回来，比如股权。\n很多大公司都有期权，但期权其实是经济的奖励的一\n种变体，对小公司来说期权应该不仅仅意味着分红，\n更应该通过股权的分配让员工参与到公司的决策中\n来。但凡有什么大事提前和有股权的成员说，或商量\n方法，或询问意见，要让人家参与到公司的管理，至\n少要让人感觉自己参与了。\n\n除了股权外，公司的日常工作中也需要让成员提高参\n与度。鼓励成员对工作发表意见，经常性的主动询问\n有什么意见，并对成员提出的意见作出明确的反馈，\n不管接受驳回还是半接受，要事事有回应，不能让人\n觉得意见提了也没人听。对于每个人的专业工作部分\n多询问对方的意见，“你觉得应该怎么做”，“如果你没\n想法，那看看我这个想法你觉得怎么样。”\n这些事本质上都是为了让人感受到被尊重，公司需要\n他的主观能动性，而不是机械的让他做事。\n\n然后是自由度，少关注考勤，有事晚一点到，早一点\n走，都没关系，说一声就好。每年给足年假，想请就\n请，不需要冠冕堂皇的理由，就是请假在家睡觉也可以。\n不要给成员很大的压迫感，不要让人觉得上班很痛苦。\n在加班问题上也是这样，我们从来不强制加\n班，即使活很多也不会强制加班。愿意留下加班都是\n因为想更快的把事做好。\n\n说到底，自由度也是对人尊重的一种表现形式，讲成\n大道理其实就是马斯洛的需求理论。和做游戏一样，\n大道理谁都懂，就看日常操作中有没有贯彻而已。\n我们公司9年来一直是这么做的，所以20个人平均在职时间五六年。","tags":["思考"]},{"title":"如何用 CSS 实现一个三角形","url":"/2022/05/18/2020-05-26/","content":"\n当涉及到网页设计和CSS技巧时，有时候我们需要在页面中添加一些特殊形状，比如三角形。本文将介绍如何使用CSS来绘制三角形，为你展示两种常见的方法。\n\n### 使用CSS绘制三角形的方法\n\n在网页设计中，有时我们需要创建各种形状的图形，其中三角形是最常见的形状之一。下面我们将介绍两种使用CSS绘制三角形的方法。\n\n#### 方法一：使用`border`属性\n\n这种方法通过设置元素的`border`属性来创建三角形。下面是一个简单的例子：\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style>\n.triangle {\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-bottom: 100px solid red;\n}\n</style>\n</head>\n<body>\n\n<div class=\"triangle\"></div>\n\n</body>\n</html>\n```\n\n在这个例子中，我们创建了一个向下的红色三角形。你可以根据需要调整`border`属性的值来改变三角形的大小和方向。\n\n#### 方法二：使用伪元素\n\n另一种常见的方法是使用伪元素。下面是一个例子：\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<style>\n.triangle {\n  width: 0;\n  height: 0;\n  position: relative;\n}\n\n.triangle::after {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 100px solid red;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n}\n</style>\n</head>\n<body>\n\n<div class=\"triangle\"></div>\n\n</body>\n</html>\n```\n\n同样，这将创建一个向下的红色三角形。你也可以调整`border`属性的值来改变三角形的大小和方向。\n\n### 结论\n\n在这篇文章中，我们讨论了两种使用CSS绘制三角形的方法。通过这些简单的技巧，你可以轻松创建各种形状的三角形，使你的网页设计更加多样化和有趣。希望本文能帮助你更好地理解如何利用CSS来创建三角形。","tags":["面试"]},{"title":"cookie、localStorage与sessionStorage的区别","url":"/2022/05/18/2020-06-06/","content":"\nCookie、localStorage、sessionStorage 都是 Web 开发中常用的存储数据的方式，它们之间存在一些关键的区别。\n\n| 属性     | Cookie                                     | localStorage                               | sessionStorage                   |\n| -------- | ------------------------------------------ | ------------------------------------------ | -------------------------------- |\n| 存储位置 | 浏览器端                                   | 浏览器端                                   | 浏览器端                         |\n| 数据大小 | 4KB                                        | 5MB                                        | 5MB                              |\n| 作用域   | 同源                                       | 同源                                       | 同源                             |\n| 生命周期 | 浏览器关闭后失效                           | 浏览器关闭后失效                           | 当前会话结束后失效               |\n| 使用场景 | 用于存储少量数据，例如用户偏好、登录状态等 | 用于存储大量数据，例如游戏进度、浏览记录等 | 用于存储临时数据，例如表单数据等 |\n\n## Cookie\n\nCookie 是存储在浏览器端的一小段文本数据，由服务器生成，并在每次请求时发送给浏览器。Cookie 的数据大小限制为 4KB，作用域为同源，生命周期由服务器设置。Cookie 通常用于存储少量数据，例如用户偏好、登录状态等。\n\n## localStorage\n\nlocalStorage 是 HTML5 中提供的一种持久化存储方式，可以存储任意大小的数据，作用域为同源，生命周期为浏览器关闭后失效。localStorage 通常用于存储大量数据，例如游戏进度、浏览记录等。\n\n## sessionStorage\n\nsessionStorage 是 HTML5 中提供的一种会话存储方式，可以存储任意大小的数据，作用域为同源，生命周期为当前会话结束后失效。sessionStorage 通常用于存储临时数据，例如表单数据等。\n\n## 总结\n\nCookie、localStorage、sessionStorage 各有优缺点，具体选择哪种存储方式取决于实际需求。Cookie 适用于存储少量数据，localStorage 适用于存储大量数据，sessionStorage 适用于存储临时数据。\n","tags":["面试"]},{"title":"变于不变","url":"/2022/05/18/2022-05-18/","tags":["思考"]},{"title":"NAS折腾（一）威联通(Qnap)安装Mariadb","url":"/2022/03/08/2022-03-08/","content":"\n以前开发的时候总是用同一台机器开启数据库,机器休眠或者关闭之后数据库就不能链接了,\n\n<!-- more -->\n\n想着有没有办法可以在本地环境中跑一个永不关机的数据库进程,正好手头有一台之前买的威联通的 NAS,是不是可以在 NAS 上安装一个数据库,这样就不用担心关机关闭的问题了.以下是自己记下的操作步骤,希望有需要的可以参考一下\n\n1. 应用商店安装 mariadb\n2. 开启威廉通 ssh\n3. Ssh 登陆威廉通 用户 admin 密码就是网页版登陆威廉通的密码\n4. 修改 mariadb 配置 /etc/config/my.cnf sock 链接的地址改为安装好 mariadb 后弹框中的地址\n5. 开启 mariadb 远程访问\n6. /share/CACHEDEV1_DATA/.qpkg/MariaDB1/bin 目录下执行 ./mysql -u root -p\n7. GRANT ALL PRIVILEGES ON _._ TO 'root'@'%'IDENTIFIED BY '123456' WITH GRANT OPTION; 也可以只允许部分地址链接 192.168.111.%\n8. flush privileges; 刷新使上面的修改生效\n9. Laravel :Syntax error or access violation: 1071 Specified key was too long;\n10. 在 AppServiceProvider 中添加 Schema::defaultStringLength(191);\n","tags":["硬件"]},{"title":"使用miniconda管理python版本","url":"/2022/03/07/2022-03-07/","content":"\n在使用Node.js时候,我们可以使用nvm管理不同的Node.js版本.在维护老项目的时候,可以将Node.js切换到较低的版本;当需要新的JS特性的时候,可以将JS切换到较新的版本.\n\n在使用python的时候,并没有像nvm这样的方便切换不同python版本的工具.虽然有virtualenv这样的虚拟环境管理软件,但是这类软件只是为当前python环境添加了一些特定的软件包,类似于node_modules,并不能切换python的版本,直到我发现了miniconda.\n\nanaconda可以用来管理不同的Python,Node.js等等，而miniconda是anaconda的最小安装包，只包含必要的库。\n\n## 安装\n从[官网](https://docs.conda.io/en/latest/miniconda.html)下载自己电脑对应的安装包.在windows上，可以使用WSL作为日常的开发环境.\n```bash\ncurl -sL \\\n  \"https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\" > \\\n  \"Miniconda3.sh\"\n```\n下载好之后,输入\n```bash\nbash Miniconda3.sh\n```\n依据提示安装\n\n安装好之后重启终端，在终端的提示符上可以看到miniconda为我们默认激活了名为base的默认版本\n![](/img/1646646662326.png)\n\n## Python版本切换\n\n### 安装其他版本的Python\n```bash\nconda create -n py36 python=3.6\n```\n3.6是你想要安装的Python版本号，-n参数用来设置版本的名字\n\n### 激活特定版本\n```bash\nconda activate py36\n```\n\n### 停用当前激活的Python版本\n```bash\nconda deactivate\n```\n\n更多使用方法请参考[官网文档](https://docs.conda.io/en/latest/miniconda.html)\n","tags":["Python"]},{"title":"在windows下使用WSL中的git","url":"/2022/02/15/2022-02-15/","content":"\n在 windows 上安装 git 后，在安装目录会有一个 mingw64 的文件夹，这个文件夹里面放着 git 运行的依赖环境。\n在维基百科上，是这样解释 mingw64 的:\n\n    MinGW-w64是自由及开放源代码软件开发环境，用于创建Microsoft Windows应用程序。从\n    2005–2008从MinGW(Minimalist GNU for Windows)分支出来。\n\n    MinGW-w64包括对GCC、GNU Binutils的Windows版本的移植（汇编器、链接器、库文件管理器），\n    一套自由可分发的Windows特定的头文件与静态导入库以使用Windows API，一个Windows本地版本\n    的GNU的调试器，以及其它多种工具。\n\n    MinGW-w64可运行于本地Microsoft Windows平台，\"cross-native\"在MSYS2或Cygwin。\n    MinGW-w64能生成32或64位可执行程序，运行于i686-w64-mingw32或x86_64-w64-mingw32\n    目标平台。\n\nwindows 下的 git 运行依赖于 mingw64，而 mingw64 实际上是 GNU 项目下一些软件环境的集合。而现在有了 WSL（Windows Subsystem for Linux），则可以在 windws 下使用\n不依赖于 mingw64 的原生 git\n\n首先需要做的是安装 WSL，网上已经有很多教程，这里就不再赘述。这些教程里一般会让你配置好开发环境，包括 git 这些。\n\n接下来的操作都需要在Windows这边来进行。先下载[wslgit.zip](https://github.com/andy-5/wslgit/releases/tag/v1.2.0)，解压后如下图所示：\n![](/img/wslgit_before.png)\n右键instal.bat，使用管理员权限运行，得到bin文件夹：\n![](/img/wslgit_after.png)\n最后需要做的就是将bin目录添加到环境变量，注销或重启电脑，这样你就可以愉快的使用原生git","tags":["工具"]},{"title":"Vue 3 + Vite + Testing Library","url":"/2021/11/25/2021-11-25/","content":"\n## 关于组件测试\n\nVue 有官方的组件测试库[Vue Test Utils](https://vue-test-utils.vuejs.org/),这是一个比较偏底层的组件测试库,\n如果对其不熟悉的话,官方建议是使用[Vue Testing Library](https://testing-library.com/docs/vue-testing-library/intro),\n它是对 Vue Test Utils 的抽象\n\n## 项目添加组件测试\n\n1. 使用 vite 创建 Vue 应用\n\n```sh\nyarn create vite <project_name> --template vue\n```\n\n2. 安装依赖\n\ntesting library 目前只针对 Vue2 进行了适配,如果需要在 Vue3 中使用,需要安装 6.x.x 版本\n\n在使用 testing library 处理组件,它会返回一些选择器,让你根据不同的方式获取组件中的 DOM 元素,\n所以在用 testing library 测试的时候,可能会需要确认某个 DOM 是否被正确的渲染出来,但 jest 本身\n并没有提供这些断言的方法,所以才需要[jest-dom](https://github.com/testing-library/jest-dom#readme)来扩充对 DOM 的断言方式\n\n```sh\nyarn add jest @testing-library/vue@next babel-jest @babel/core @babel/preset-env -D\n```\n\n3. babel 配置\n\n```js\nmodule.exports = {\n    presets: [\n        [\n            '@babel/preset-env',\n            {\n                targets: {\n                    node: 'current'\n                }\n            }\n        ]\n    ]\n};\n```\n\n4. jest 配置\n\ntransform 配置中添加了针对不同文件的转换规则,如果需要测试的文件\n不是 Vue3 和 js 则需要安装对应的插件并修改 transform 配置,例如如果使用\nVue2 的话可以安装@vue/vue2-jest,使用 ts 话则可以安装 ts-jest\n\n```js\nmodule.exports = {\n    testEnvironment: 'jsdom',\n    transform: {\n        '^.+\\\\.vue$': '@vue/vue3-jest',\n        '^.+\\\\js$': 'babel-jest'\n    },\n    testRegex: '(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.js$',\n    moduleFileExtensions: ['vue', 'js'],\n    transformIgnorePatterns: ['/node_modules/(?!testing-library)']\n};\n```\n\n5. 修改 package.json,添加测试命令\n\n```json\n  \"scripts\": {\n    \"test\": \"jest\"\n  },\n```\n\n## 简单的测试\n\n```js\nimport '@testing-library/jest-dom';\nimport { render } from '@testing-library/vue';\nimport HelloWorld from './HelloWorld.vue';\n\ndescribe('HelloWorld.vue', () => {\n    it('renders props.msg when passed', () => {\n        const msg = 'new message';\n        const { getByText } = render(HelloWorld, {\n            props: { msg }\n        });\n        expect(getByText(msg)).toBeInTheDocument();\n    });\n});\n```\n\n1. 在需要测试的组件的同级目录下创建同名测试文件,例如上述针对 HelloWorld 的组件需要创建 HelloWorld.spec.js 文件\n2. 在测试文件中引入 jest-dom 来扩充 jest 的断言方法\n3. 上面的测试用例是用来测试组件是否正确地渲染,所以需要从 DOM 中获取渲染的内容,render 方法用来渲染组件,而 getByText\n   会试着去获取内容为 msg 的 DOM,并交给 jest 的 expect 方式,最后用 jest-dom 扩充的 toBeInTheDocument 去验证,看 getByText 有没有\n   找到 DOM,如果有的话就代表 HelloWorld 通过了测试\n\n```js\nimport '@testing-library/jest-dom';\nimport { render, fireEvent } from '@testing-library/vue';\nimport Counter from './Counter.vue';\n\ndescribe('increments value on click', () => {\n    it('click twice', async () => {\n        const { getByText } = render(Counter);\n\n        getByText('Times clicked: 0');\n\n        const button = getByText('increment');\n\n        await fireEvent.click(button);\n        await fireEvent.click(button);\n\n        expect(getByText('Times clicked: 2')).toBeInTheDocument();\n    });\n});\n```\n\n有时,我们也想看一下带有交互事件的组件是否能正常工作,这个时候就需要用到 fireEvent 函数了.\nfireEvent 用来模拟用户交互行为.在上面 Counter 测试中,用户点击两次后查看 DOM 中是否有含有\n特定字符串的节点.\n\n","tags":["Vue.js"]},{"title":"winget 使用","url":"/2021/09/07/2021-09-07/","content":"\n## 什么是 winget\n\n```\n用户可以在 Windows 10 和 Windows 11 计算机上使用 winget 命令行工具来发现、安装、升级、删除和配置应用程序。 此工具是 Windows 程序包管理器服务的客户端接口。\n```\n\nwindows 下的包管理工具,类似于 Ubuntu 下的 apt.windows 上之前也有一些其他的包管理工具,像 Chocolatey Scoop. winget 是微软为 win10 开发的一款开源的软件包管理器,至少\n需要 windows 10 1709(版本 16299)及以上版本\n\n## 为什么要用包管理器\n\n-   降低安装维护软件的成本\n-   避免安装大量软件造成的路径污染\n-   不必查找和安装软件的其他依赖项\n-   避免捆绑和垃圾软件\n-   彻底地卸载\n\n## 安装\n\n打开 Microsoft Store,更新\"应用安装程式\"即可,安装完成后,打开 CMD 或者 powershell,输入 winget 查看命令\n\n![](/img/1644201744305.png)\n\n## 常用命令\n\nwinget 提供了常用的命令,如果不清楚的话,可以使用 winget [<命令>] -?查看帮助文档\n\n-   install 安装给定的程序包\n-   show 显示包的相关信息\n-   source 管理程序包的来源\n-   search 查找并显示程序包的基本信息\n-   list 显示已安装的程序包\n-   upgrade 升级给定的程序包\n-   uninstall 卸载给定的程序包\n-   hash 哈希安装程序的帮助程序\n-   validate 验证清单文件\n-   settings 打开设置或设置管理员设置\n-   features 显示实验性功能的状态\n-   export 导出已安装程序包的列表\n-   import 安装文件中的所有程序包\n\n有了 winget 之后,便不用从官网下载软件包,双击安装软件了.结合 powershell 可以实现一定程度的自动化操作\n\n```ps1\n(\n\t\"Google.Chrome\",\n    \"Mozilla.Firefox\",\n    \"Discord.Discord\",\n    \"Microsoft.WindowsTerminal\",\n    \"CPUID.CPU-Z\",\n    \"hiyohiyo.CrystalDiskInfo\",\n    \"Git.Git\",\n    \"Microsoft.PowerToys\",\n    \"Valve.Steam\",\n    \"Spotify.Spotify\",\n    \"Microsoft.Teams\",\n    \"Ubisoft.Uplay\",\n    \"Microsoft.VisualStudioCode\",\n    \"WiresharkFoundation.Wireshark\"\n) | foreach {winget install -e --id $_}\n```\n\n或者也可以使用 winget 自带的 import/export 命令,在一台已经装好软件的电脑上使用 export 命令,在另一台电脑上使用 import 命令,\n便可以克隆一台电脑的软件环境\n\n","tags":["工具"]},{"title":"使用 JSDoc 获得更好的类型提示","url":"/2021/07/06/2021-07-06/","content":"\n\nJSDoc 是适用于 JavaScript 的 API 文档生成工具,可以识别特定的标记语法编写的注释来生成可读性较好的文档\n\n![](/img/1644201796767.png)\n\n## VS Code 对 JSDoc 的支持\n\nVS Code 能够理解大部分的 JSDoc 注释并且能够根据这些注释提供智能补全的功能。你甚至可以利用 JSDoc 提供的类型信息对你的 JS 进行类型检查\n![](/img/1644201816782.png)\n\n## JSDoc 使用\n\n1. @type\n   使用@type 标签来引用一个类型名(原始类型/TypeScript 中定义的类型/或者\"@typedef\"标签)\n\n    ```js\n    /**\n     * @type {string | number} 联合类型\n     */\n    var s;\n\n    /** @type {Window} dom提供的类型 */\n    var win;\n\n    /** @type {Array<number>} 数组*/\n    var nums;\n\n    /** @type {{ a: string, b: number }} 复杂类型 */\n    var var9;\n    ```\n\n2. @param @returns\n\n    @param 使用和@type 相同的语法,但是需要添加参数名。将参数声明在中括号中可以使参数作为可选参数。使用@returns 来声明函数返回的类型\n\n    ```js\n    // 参数可以用多种语法来声明\n    /**\n     * @param {string}  p1 - 字符串参数\n     * @param {string=} p2 - 可选参数(Closure syntax)\n     * @param {string} [p3] - 另一个可选参数 (JSDoc syntax).\n     * @param {string} [p4=\"test\"] - 有默认值的可选参数\n     * @return {string} 返回值\n     */\n    function stringsStringStrings(p1, p2, p3, p4) {\n        return 'string';\n    }\n    ```\n\n3. @typedef @callback @param\n   @typedef 可以用来定义更复杂的类型。语法和@param 类似\n\n    ```js\n    /**\n     * @typedef {object} SpecialType1 - 创建新的类型并命名为 'SpecialType'\n     * @property {string} prop1 - SpecialType的字符串属性\n     * @property {number} prop2 - SpecialType的数字属性\n     * @property {number=} prop3 - SpecialType的可选数字属性\n     */\n\n    /** @type {SpecialType1} */\n    var specialTypeObject1;\n    ```\n\n    @param 可以使用类似的语法来定义一次性使用的类型。与@typedef 不同的是嵌套属性名必须以参数名作为前缀\n\n    ```js\n    /**\n     * @param {Object} options - The shape is the same as SpecialType above\n     * @param {string} options.prop1\n     * @param {number} options.prop2\n     * @param {number=} options.prop3\n     * @param {number} [options.prop4]\n     * @param {number} [options.prop5=42]\n     */\n    function special(options) {\n        return (options.prop4 || 1001) + options.prop5;\n    }\n    ```\n\n    @callback 和@typedef 类似,但是它是定义函数类型而不是对象类型\n\n    ```js\n    /**\n     * @callback Predicate\n     * @param {string} data\n     * @param {number} [index]\n     * @returns {boolean}\n     */\n\n    /** @type {Predicate} */\n    const ok = (s) => !(s.length % 2);\n    ```\n\n    当然,这些类型都可以在单行@typedef 中使用 TypeScript 语法来声明\n\n    ```js\n    /** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */\n    /** @typedef {(data: string, index?: number) => boolean} Predicate */\n    ```\n\n4. @ts-check\n\n    说到底,JSDoc 只是更友好的类型提示工具，并不会对类型进行检查。VS Code 针对 TS 有类型检查,但是这对 JS 文件默认是不启用的。可以在 JS 文件第一行添加//@ts-check 开启类型错误提示\n  ![](/img/1644201840858.png)\n\n## 参考\n\n-   [JSDoc 官网](https://jsdoc.app/)\n-   [VS Code 对 JSDoc 的支持](https://code.visualstudio.com/docs/languages/javascript#_jsdoc-support)\n-   [TypeScript 官网的 JSDoc 支持文档](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)\n\n","tags":["VSCode","JavaScript"]},{"title":"基于Vue3+elementUI的中后台CRUD组件","url":"/2021/04/03/2021-04-03/","content":"\n## Vue restful admin\n\n### 根据 restful 接口快速创建 CRUD 界面\n\n> restful 接口根据不同的请求方式可以快速完成资源的增删查改,\n> 而对于前端来说意味着只需要为组件提供一个 url 属性便可以完成\n> 所有的操作.\n\n> 在此项目中，参考了[react-admin](https://github.com/marmelab/react-admin)的中的 data-provider\n> 的设计思路，将 restful 请求接口写成单独的函数，这样便可以定义自己的请求接口\n\n1.  定义 dataServer\n\n        dataServer 中定义了五种基本操作\n\n    ```js\n    const dataServer = (url) => ({\n      getAll: () => {\n        return [];\n      },\n      get: (id) => {},\n      create: (data) => {},\n      update: (data) => {},\n      delete: (id) => {},\n    });\n    ```\n\n2.  通过编写类似 schema 的方式来定义表格和编辑表单\n\n    ```js\n    columns: [\n      { prop: \"author\", label: \"姓名\", type: \"input\" },\n      { prop: \"title\", label: \"标题\", type: \"input\" },\n      {\n        prop: \"create_at\",\n        label: \"创建时间\",\n        type: \"time\",\n        format: \"YYYY-MM-DD HH:mm\",\n      },\n      {\n        prop: \"gender\",\n        label: \"性别\",\n        type: \"select\",\n        options: [\n          { label: \"男\", value: 1 },\n          { label: \"女\", value: 2 },\n        ],\n      },\n    ];\n    ```\n\n3.  效果图\n\n    ![table.PNG](https://i.loli.net/2021/04/30/mVlHncrkIeWvtg6.png)\n    ![edit.PNG](https://i.loli.net/2021/04/30/v68rOZbX7uF3EPH.png)","tags":["Vue.js","Element Plus"]},{"title":"艾宾浩斯复习法生成课文播放列表","url":"/2021/03/28/2021-03-28/","content":"\n## 开发原因\n\n> 以前学习英语的时候,还是在记事本上利用艾宾浩斯曲线的方法,画出表格,记录每天的学习状态.\n> 现在要学习日语,也想着用一样的方法,但是手写的不方便管理,而且效率也不高,就想着用程序\n> 来生成每天要复习的课文.参考了[这个](https://github.com/Nancyberry/ebbinghausGenerator).\n\n## 开发过程\n\n> 想法是 lessons 目录存放要学习的课文音频文件,默认是从明天开始算,一天学习一课.然后输入\n> mp3 播放列表文件.一开始还在手机上试了很多不同播放器,发现只有[poweramp](https://powerampapp.com/)满足批量导入列表的要求.","tags":["Python"]},{"title":"赚钱","url":"/2020/12/12/2020-12-12/","content":"\n> 赚钱的方法分为在刑法里面的和不在刑法里面。作为一位遵纪守法的公民，当然只关注合法的方法。\n\n### 低风险低收益\n\n低风险低收益突出一个稳定，大部分其实都是体力劳动\n\n1. 打工\n2. 捡废品\n3. 热门游戏代肝/代练\n\n### 高风险高收益\n1. 炒股\n2. 比特币/以太坊\n\n### 低风险高收益\n\n低风险高收益的方法其实就是读概率，看脸\n\n1. 彩票\n\n<!-- more -->","tags":["思考"]},{"title":"vim快捷键学习","url":"/2020/08/24/2020-08-24/","content":"\n## 简介\n> 2020年，打算学点不一样的东西。在过去的这几个月中，我把自己的输入法无论是手机端的还是PC端\n> 的，全部换成了小鹤双拼输入法。刚开始的时候的确是有点不适应。在强迫自己学习了几个月之后，\n> 打字速度终于赶上了之前使用全拼时候的速度，虽然错误率还是有点高。\n\n\n> 之前在开发上，由于自己接触的第一款代码编辑器是VSC，自然而然的，最熟悉的快捷键模式也是VCS\n> 的那一套，导致之后在使用JetBrain的IDE时，也习惯使用插件将IDE的快捷键模式改为VSC的。但是\n> JetBrain的插件并没有VSC里面的那一套那么方便。于是便将快捷键换成了Vim的那一套。之所以换成\n> Vim的，是因为之前也尝试过学习Vim，但是总是中途放弃，虽然还有一点印象。另一点是VSC也有比较\n> 成熟的Vim插件，可以一并也将VSC的快捷键换成Vim的。\n\n## 学习过程\n### 已有的快捷键迁移\n> 首先要做的是将自己已经熟悉的VSC快捷键迁移到Vim。在使用VSC的nvim插件时。 \n\n    在使用VSC的nvim插件时，不要使用太复杂的配置，不然VSC无法nvim插件无法正常运行\n\n1. 向上插入一行/向下插入一行\n```\nvim模式: normal\n\nCmd+Enter -> o\nCtrl+Enter -> O\n\nCmd+shift+Enter -> O\nCtrl+shift+Enter-> O\n```\n2. 单词移动\n```\nvim模式: normal\n\nCtrl+Right -> w\nCtrl+Left -> b\nOption+Right -> w\nOption+Left -> b\n```\n3. 删除整行\n```\nvim模式: normal\n\nShiftCmd+K -> dd\nShift+Ctrl+K -> dd\n```\n4. 在同一单词上移动\n```\nvim模式: normal\n\nCmd+d -> #/*\nCtrl+d -> #/*\n```\n### 新快捷键\n1. 在行尾编辑\n```\nvim模式: normal\n\nshitf+a\n```\n2. 删除单词\n```\nvim模式: normal\n\ndw\n```\n3. 删除括号(包括括号/不包括括号)内的内容(c表示进入insert模式)\n```\nvim模式: normal\n\nda(  ca(\ndi(  ci(\n```\n4. 改变大小写\n```\nvim模式: normal\n\n~\n```\n5. 数字自增/自减\n```\nctrl+a\nctrl+x\n```\n\n## Vim教程\n[简明Vim练级攻略](https://coolshell.cn/articles/5426.html)","tags":["VSCode","Vim"]},{"title":"import 和 require 有什么区别","url":"/2020/04/11/2020-04-11/","tags":["面试"]},{"title":"消费跟踪工具","url":"/2020/03/04/2020-03-04/","content":"\n## 简介\n>第一次尝试做全栈应用。这个网站之前只是静态服务器,这次的这个消费跟踪工具使用node.js+mongo db作为后端，\n>开发过程中接口调试工具使用的postman，不过后来发现vscode有个Restful的插件，使用了一段>时间感觉还不错。 \n>对于这种个人全栈应用来说，频繁地在ide和postman之间切换还是有点麻烦的的。如果接口调试也可以在ide中的话\n>就太方便了吗，我想这也是REST Client这个插件的作者的初衷吧。顺便还学习了一下nginx的端口代理功能，非常\n>方便， 可以使用webhook的方式来触发telegram的机器人请求\n\n## 功能实现\n> 前端功能包括账单统计，消费记录添加/删除。其中账单统计包括支出统计以及收入统计。前端选用的Vue.js+Vuex\n> 后端功能主要就是账单的添加和删除。后端使用的主要就是Express+Mongoose\n\n\n![expense-tracker.png](https://i.loli.net/2020/03/04/c1xp6zGKv9eVr8N.png)","tags":["Vue.js","Mongodb","Express"]},{"title":"vscode常用快捷键","url":"/2020/02/07/2020-02-07/","content":"\n## 简介\n>vscode作为一个前端开发工具来说是非常方便的。作为巨硬的开源代码编辑器，不仅\n>有着众多的用户，还有着活跃的社区，这给vscode带来了数不胜数的插件。使用\n>插件辅助开发的同时，不要忘了vscode本身也是一款拥有许多快捷键的高效工具。\n>我把常用的快捷键概括了一下，记下的同时也方便自己以后查阅。窗口相关的大部分\n>快捷键与chrome一样，vscode平常使用习惯了，chrome的使用也变得更高效了🙃\n\n## 文件相关\n1. 打开文件\n```\nCmd+O\nCtrl+O\n```\n2. 快速打开文件\n```\nCmd+P\nCtrl+P\n```\n3. 新建文件\n```\nCmd+N\nCtrl+N\n```\n\n## 窗口界面相关\n1. 关闭窗口\n```\nCmd+W \nCtrl+W\n```\n2. 撤销窗口关闭\n```\nShift+Cmd+T\nShift+Ctrl+T\n```\n3. 终端开关\n```\nCtrl+`\nCtrl+`\n```\n4. 侧边栏开关\n```\nCmd+B \nCtrl+B\n```\n5. 面板开关\n```\nShift+Cmd+P\nShift+Ctrl+P\n```\n\n## 代码编辑相关\n1. 选中单词\n```\nCmd+D\nCtrl+D\n```\n2. 向下/上复制一行\n```\nShift+Option+Up\nShift+Option+Down\nShift+Alt+Up\nShift+Alt+Down\n```\n3. 删除整行\n```\nShiftCmd+K\nShift+Ctrl+K\n```\n4. 行尾/行首移动\n```\nCmd+Right\nCmd+Left\nCtrl+Right\nCtrl+Left\nhome\nend\n```\n5. 以空格为分隔的光标移动\n```\nOption+Right\nOption+Left\nAlt+Right\nAlt+Left\n```\n6. 在下一行插入\n```\nCmd+Enter \nCtrl+Enter\n```\n7. 连续选中单词\n```\nShift+Option+left/right\nShift+Alt+left/right\n```","tags":["VSCode"]},{"title":"chrome倍速播放插件","url":"/2020/01/06/2020-01-06/","content":"\n## 目的\n- 学会阅读文档\n- 回顾h5多媒体标签\n- 利用chrome插件完成平常的重复性工作","tags":["HTML5","FE"]},{"title":"HTML5播放器","url":"/2019/09/06/2019-09-06/","content":"\n# 构建基于Electron的番茄计时器\n\n在现代社会中，时间管理变得越来越重要。番茄工作法是一种广受欢迎的时间管理技术，通过将工作划分为固定时间段，以提高工作效率。本文将介绍如何使用Electron框架构建一个基于番茄工作法的计时器应用程序，帮助用户更好地管理工作时间和提高生产力。\n\n## 介绍\n\nElectron是一个流行的开源框架，用于构建跨平台的桌面应用程序。它结合了Chromium和Node.js，使开发人员能够使用Web技术（如HTML、CSS和JavaScript）构建功能强大的桌面应用程序。通过利用Electron，我们可以轻松构建功能丰富且具有跨平台能力的应用程序，比如我们的番茄计时器。\n\n## 技术栈\n\n- HTML/CSS：构建应用程序界面和样式\n- JavaScript：处理番茄计时器逻辑和交互\n- Electron：用于构建桌面应用程序的开源框架\n\n## 实现步骤\n\n### 1. 初始化Electron应用程序\n\n使用Electron快速设置应用程序的基本结构，确保能够成功运行应用程序并显示基本窗口界面。\n\n### 2. 设计番茄计时器界面\n\n创建番茄计时器的用户界面，包括倒计时显示、开始/暂停按钮、重置按钮和任务设置等功能。\n\n### 3. 实现番茄计时器逻辑\n\n编写JavaScript代码来处理番茄计时器的逻辑。确保计时器能够按照番茄工作法的原则正确工作，包括工作时间和休息时间的切换，以及计时器的暂停和重置功能。\n\n### 4. 添加提醒和提示功能\n\n通过Electron的API添加提醒和提示功能，以便在工作时间和休息时间结束时提醒用户。\n\n### 5. 测试和优化\n\n进行全面的测试，确保应用程序在各种操作系统和环境下都能正常工作。根据用户反馈和测试结果对应用程序进行优化和改进。\n\n## 结论\n\n通过本文的指导，我们成功地构建了一个基于Electron的番茄计时器应用程序。番茄计时器不仅可以帮助用户提高工作效率，还能够更好地管理时间和提高工作成果。希望本文能够为读者提供有用的指导，并激发对Electron框架应用开发的兴趣。","tags":["HTML5","FE"]},{"title":"豆瓣科幻电影分析","url":"/2019/08/29/2019-08-29/","content":"\n\n## 简介\n\n> 因为对科幻电影感兴趣，所以就利用 node.js 爬取了\n> 豆瓣所有高于 6 分的科幻电影，一共 859 部电影，并作\n> 了简易的分析，包括年份分布，分数分布以及均分。虽然\n> 爬取的都是均分高于 6 的电影，均分不一定很具有代表性，\n> 但也能在一定程度上反应最近几年电影的走势\n\n## 评分分布\n\n> 评分可以反映出大众对一部电影的整体印象，可以更直观\n> 的反映出普通观众对于一部电影的态度，也是我们选择电\n> 影的一种依赖标准。虽然只是对 6.0 分以上的电影做了统\n> 计，但是 6.0 分应该是能驱使大众去电影院观看的最低标\n> 准了。评分分布整体满足正态分布，说明极其优秀的电影\n> 永远是少数。\n\n![rate_dis.jpg](https://i.loli.net/2019/10/08/nYgUSDVaxHBuqJt.jpg)\n\n## 按年分布\n\n> 每一年的电影数量也是一个比较好的反映电影市场的数据，\n> 一般来说当年的电影数量越多，就越能证明电影市场的活跃\n> 和观众对于电影的喜爱\n\n![years_dis.jpg](https://i.loli.net/2019/10/08/yI6XAi5rTbUwW7h.jpg)\n\n## 其他\n\n> 还有一些其他的数据比如各国科幻电影统计以及年平均分分布，可以在[这里](https://cangzhijie356.tk/src/douban/index.html)看到\n","tags":["HTML5","FE","Node.js","爬虫"]},{"title":"基于electron的番茄计时器","url":"/2019/08/01/2019-08-01/","content":"\n\n# 构建基于Electron的番茄计时器\n\n在现代社会中，时间管理变得越来越重要。番茄工作法是一种广受欢迎的时间管理技术，通过将工作划分为固定时间段，以提高工作效率。本文将介绍如何使用Electron框架构建一个基于番茄工作法的计时器应用程序，帮助用户更好地管理工作时间和提高生产力。\n\n## 介绍\n\nElectron是一个流行的开源框架，用于构建跨平台的桌面应用程序。它结合了Chromium和Node.js，使开发人员能够使用Web技术（如HTML、CSS和JavaScript）构建功能强大的桌面应用程序。通过利用Electron，我们可以轻松构建功能丰富且具有跨平台能力的应用程序，比如我们的番茄计时器。\n\n## 技术栈\n\n- HTML/CSS：构建应用程序界面和样式\n- JavaScript：处理番茄计时器逻辑和交互\n- Electron：用于构建桌面应用程序的开源框架\n\n## 实现步骤\n\n### 1. 初始化Electron应用程序\n\n使用Electron快速设置应用程序的基本结构，确保能够成功运行应用程序并显示基本窗口界面。\n\n### 2. 设计番茄计时器界面\n\n创建番茄计时器的用户界面，包括倒计时显示、开始/暂停按钮、重置按钮和任务设置等功能。\n\n### 3. 实现番茄计时器逻辑\n\n编写JavaScript代码来处理番茄计时器的逻辑。确保计时器能够按照番茄工作法的原则正确工作，包括工作时间和休息时间的切换，以及计时器的暂停和重置功能。\n\n### 4. 添加提醒和提示功能\n\n通过Electron的API添加提醒和提示功能，以便在工作时间和休息时间结束时提醒用户。\n\n### 5. 测试和优化\n\n进行全面的测试，确保应用程序在各种操作系统和环境下都能正常工作。根据用户反馈和测试结果对应用程序进行优化和改进。\n\n## 结论\n\n通过本文的指导，我们成功地构建了一个基于Electron的番茄计时器应用程序。番茄计时器不仅可以帮助用户提高工作效率，还能够更好地管理时间和提高工作成果。希望本文能够为读者提供有用的指导，并激发对Electron框架应用开发的兴趣。","tags":["HTML5","FE"]},{"title":"带计时功能的todo程序","url":"/2019/06/23/2019-06-23/","content":"\n\n**构建带计时功能的To-Do程序**\n\n在当今快节奏的生活中，高效地管理任务变得至关重要。为了提高个人和团队的工作效率，To-Do应用程序成为了一个必不可少的工具。然而，随着用户对功能需求的增加，提供一个带有计时功能的To-Do程序成为了用户关注的焦点之一。本文将介绍如何构建一个带有计时功能的To-Do程序，为用户提供更精确的任务管理体验。\n\n### 介绍\n\nTo-Do应用程序在用户的日常工作和生活中扮演着至关重要的角色。随着时间管理的重要性不断突显，为To-Do程序添加计时功能有助于用户更好地掌控任务进度和时间分配。\n\n### 技术栈\n\n我们将使用以下技术来构建这个带有计时功能的To-Do程序：\n\n- HTML/CSS：构建基本的应用程序界面和样式\n- JavaScript：处理任务列表、计时器功能和交互逻辑\n- 基于Web的用户界面框架（如React或Vue.js）：构建复杂的交互界面和组件\n\n### 实现步骤\n\n1. **搭建基本结构**：使用HTML和CSS创建To-Do程序的基本界面，包括任务列表、添加任务按钮和计时器等。\n\n2. **实现任务列表**：使用JavaScript管理任务列表，使用户可以添加、删除和编辑任务。确保任务列表能够动态地显示新增和删除的任务。\n\n3. **添加计时功能**：在每个任务项目中添加计时按钮。当用户开始执行任务时，启动计时器并显示已经过的时间。用户可以手动停止或重置计时器。\n\n4. **优化用户体验**：添加响应式设计，使To-Do程序能够在不同的设备上良好展示。确保界面友好易用，提供直观的交互操作。\n\n5. **部署和测试**：确保To-Do程序能够在不同浏览器和设备上正常工作。进行适当的测试和调试，修复可能出现的bug和问题。\n\n### 结论\n\n通过本文的指导，我们成功地构建了一个带有计时功能的To-Do程序。这样的程序不仅能够有效地帮助用户管理任务，而且还能够提高工作效率和时间利用率。希望本文能够为读者提供有用的指导，并激发对To-Do程序开发的兴趣。","tags":["HTML5","FE"]}]